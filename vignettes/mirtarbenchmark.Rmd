---
title: "Benchmarking miRNA target prediction tools"
author: "Akshit Achara, Markus List"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_document:
    theme: lumen
vignette: >
  %\VignetteIndexEntry{Benchmarking miRNA target prediction tools}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

##Purpose

This package provides functionalities to benchmark different sequence based miRNA target prediction tools.

##Introduction

microRNAs are 19-22 nucleotide long molecules responsible for repressing the expression of genes. Several algorithms have been proposed to predict target genes of microRNAs such as targetscan etc. These methods use the fact that a seed sequence of the microRNA is complementary to a part of the sequence in the target gene, mostly in the 3' UTR. Free energy of the binding of the microRNA can be used as well as sequence conservation at the target site to improve the predictions. Nevertheless, a current problem is that the false positive rate of these predictions is extremely high. This can have several reasons, for example the microRNA and the target gene may not be expressed at the same time in a specific cell type or tissue. 

There is no standard to compare these tools as sequence based tools don't use condition specific imformation and hence, result in a lot of false positives. There are some expression based tools which use the correlation/coefficient information from Although we can't say which tool has the best overall performance for all tissue types, we can benchmark these tools ,using the regression models on gene and miRNA expression data, for a specific condition.  

In this package we have implemented an approach to benchmark different sequence based tools using gene and miRNA expression data. We build a regression model on the expression data to predict the targets. We have implemented the following two approaches to benchmark the tools:

####1) 
Convert the regression coefficients using different thresholds and convert the predictions from tools into binary data based on the number of binding sites.The regression results are considered as true labels and the predictions from tools are considered as predicted labels. The precision value obtained for different tools on comparison against regression is used to benchmark i.e the tools with higher precision value are better than the tools with low precision value.    

####2)
Convert the regression coefficient into binary data using a threshold value of zero.Whereas to convert the prediction data from tools into binary data, the quantiles of scores provided by the tools were used as thresholds.Precision and sensitivity were used for benchmarking the tools.

###General Workflow

Note: Some functions are using foreach %dopar% internally.If the user wishes to parallelize, packages like doSNOW can be used to parallelize the functions for faster implementation.

The mirtargetbenchmark workflow starts from two ends,

###1.1) 

      A) Filtering of the gene and miRNA expression data
      
      B) Building a regression model on the combined gene-miRNA expression data.

and 

###1.2)  
           
       A) Organising the downloaded data from tools into matrix format.
      
       B) Convert the gene and miRNA ids to have a common format for all the matrices.

Then, steps 3 and 4 have to be implemented in order.


###3)  
    
        
        Extract common miRNA/gene ids from all the tools after performing some filtering on the matrices 
        obtained from the tools
   
###4) 
  
    
        Obtain precision recall curves to pictorially represent the analysis and perform the benchmarking.

## 1.1) Expression data filtering and building regression models

```{r, warning=FALSE, message=FALSE}
library(mirtargetbenchmark)
```

Download gene expression and miRNA expression data from UCSC Xena Browser,etc. Here, are some examples datasets
available with the package:

Gene expression:

This is a matrix where columns are genes and the rows are samples. 

```{r, eval=FALSE}
head(gene_expr)
```
    
```{r, echo=FALSE, results='asis'}
knitr::kable(gene_expr[1:5,1:5])
```

miRNA expression:

This is a matrix where columns are genes and the rows are samples. 

```{r, eval=FALSE}
head(mir_expr)
```


```{r, echo=FALSE, results='asis'}
knitr::kable(mir_expr[1:5,1:5])
```


## A) Preprocessing of expression data

```{r,results='hide', message=FALSE}
gene_expr <- expression_preprocessing(gene_expr,missing_value = -9.9658,missing_value_filter = 90 ,
                                      variance_filter = 0.2, mean_filter = 0.2)
```

```{r,echo = FALSE}
sprintf("The number of genes left after the filtering are: %s",ncol(gene_expr))

```


```{r, results='hide',message=FALSE}
mir_expr <- expression_preprocessing(mir_expr,missing_value = 0,missing_value_filter = 90 ,
                                      variance_filter = 0.2, mean_filter = 0.2)
```

```{r, echo=FALSE}
sprintf("The number of miRNAs left after the filtering are: %s",ncol(mir_expr))
```

## B) Building regression models

```{r,results = 'hide', warning=FALSE, message=FALSE}
results <- regression_results(dependent_expr = gene_expr, independent_expr = mir_expr, 
                              model_choice = 's', rsq_filter = 0.2)
```

```{r, echo=FALSE, results='asis'}
knitr::kable(results[1:5,1:5])
```


## 1.2) Converting predictions tool into matrix
```{r, warning=FALSE, message=FALSE}
targetscan <- convert_tool_data_into_matrix(pred_data = targetscan_pred[1:1000,],miRNA_colname = "miRNA",
                                            gene_colname = "Gene.ID",score_colname = "context...score")
```

```{r, echo=FALSE, results='asis'}
knitr::kable(targetscan[1:5,1:5])
```

## 3) Convert gene ids and miRNA ids into a common format for all matrices

```{r,results = 'hide', warning=FALSE, message=FALSE}

converted_regression_matrix <- gene_miRNA_id_conversion(mat_data = results,cgid = "ENSEMBL_VERSION",
                                                        mir_bool = FALSE) 

```

```{r, echo=FALSE, results='asis'}
knitr::kable(converted_regression_matrix[2:6,1:5])
```

## 4) Perform analysis and get results

###A) Regression vs Confidence Scores

```{r,warning=FALSE, message=FALSE}

tool_list <- list(sample_targetscan, sample_mirwalk, sample_pita)

#extracting common genes and miRNAs
common_list <- common_data(sample_simple_regression_results
                           , tool_list, tool_names = c('targetscan','mirwalk','pita'))

#using miRNAs with more than 500 validated target genes in miRTarBase
common_validated_targets <- validated_miRNA_filter(common_list, matrix_names = c("targetscan","mirwalk","pita",
                                  "regression"),mirtarbase7, threshold_valmir = 100)

#list of tool matrices
common_list_scores <- list(common_validated_targets[["targetscan"]], common_validated_targets[["mirwalk"]],                                  common_validated_targets[["pita"]])

#name the elements (to be used in ensembl methods)
names(common_list_scores) <- c("targetscan", "mirwalk", "pita")

#results and analysis
output <- tool_vs_regression(common_validated_targets[["regression"]],common_list_scores, tool_names = c('targetscan','mirwalk','pita'))

```

```{r, echo=FALSE, results='asis'}
print("The green, red and pink lines represent TargetScan , PITA and miRWalk respectively")
```


```{r, echo=FALSE, results='asis'}

output$targetscan$threshold <- (output$targetscan$threshold - min(output$targetscan$threshold))/(max(output$targetscan$threshold) - min(output$targetscan$threshold))
output$mirwalk$threshold <- (output$mirwalk$threshold - min(output$mirwalk$threshold))/(max(output$mirwalk$threshold) - min(output$mirwalk$threshold))
output$pita$threshold <- (output$pita$threshold - min(output$pita$threshold))/(max(output$pita$threshold) - min(output$pita$threshold))

plot(output$targetscan$threshold, output$targetscan$PPV, type = 'l',ylim = c(0,1), xlim = c(0,1), col = "green", xlab = "thresholds", ylab = "precision")
lines(output$pita$threshold, output$pita$PPV, type = 'l', col = "red")
lines(output$mirwalk$threshold, output$mirwalk$PPV, type = 'l', col = "pink")

plot(output$targetscan$threshold, output$targetscan$SENS, type = 'l',ylim = c(0,1), xlim = c(0,1), col = "green", xlab = "thresholds", ylab = "recall")
lines(output$pita$threshold, output$pita$SENS, type = 'l', col = "red")
lines(output$mirwalk$threshold, output$mirwalk$SENS, type = 'l', col = "pink")

```


###B) Regression vs Binding Sites

```{r,warning=FALSE, message=FALSE}

#covert binding sites into binary
mircode[mircode > 1] <- 1
mirtarbase[mirtarbase > 1] <- 1
mirtarbase7[mirtarbase7 > 1] <- 1

tool_list <- list(mircode, mirtarbase, mirtarbase7)

#extracting common genes and miRNAs
common_list <- common_data(sample_simple_regression_results
                           , tool_list, tool_names = c('mircode','mirtarbase','mirtarbase7'))

#list of tool matrices
common_list_1 <- list(common_list[["mircode"]], common_list[["mirtarbase"]], common_list[["mirtarbase7"]])

#results and analysis
output_1 <- regression_vs_tool(common_list[["regression"]],common_list_1, tool_names = c('mircode','mirtarbase','mirtarbase7'))

```

```{r, echo=FALSE, results='asis'}

   print("The metrics shown below were obtained using a threshold of zero for coefficients")
   precision <- cbind(output_1$mircode$PPV[11], output_1$mirtarbase$PPV[11], output_1$mirtarbase7$PPV[11])
   recall <- cbind(output_1$mircode$SENS[11], output_1$mirtarbase$SENS[11], output_1$mirtarbase7$SENS[11])
   metrics <- rbind(precision, recall)
   rownames(metrics) <- c("precision", "recall")
   colnames(metrics) <- c("mircode", "mirtarbase", "mirtarbase7")
  knitr::kable(metrics)
  
```


###C) Ensemble method with discrete weights




```{r,warning=FALSE, message=FALSE}

ppv_performance <- c(output$targetscan$PPV[1], output$mirwalk$PPV[1], output$pita$PPV[1])

names(ppv_performance) <- c("targetscan", "mirwalk", "pita")

ppv_performance <- sort(ppv_performance, decreasing = TRUE)

new_common_list <- list()

library(rlist)

for (x in 1:length(ppv_performance)) {
  new_common_list <- list.append(new_common_list, common_list_scores[[names(ppv_performance)[x]]])
}

ensemble_predictions <- ensemble_scores(new_common_list, tool_names = names(ppv_performance), ppv_performance)

```


```{r, echo=FALSE, results='asis'}
knitr::kable(head(ensemble_predictions[,1:5]))
```


```{r,warning=FALSE, message=FALSE}

#compare the performance with other tools
common_list_scores <- list.append(common_list_scores, ensemble_predictions)

output_with_ensembl <- tool_vs_regression(common_validated_targets[["regression"]],
                                          common_list_scores, tool_names = c(c('targetscan','mirwalk','pita',
                                                                               'ensembl')))



```

```{r, echo=FALSE, results='asis'}
print("The green, red, pink and black lines represent TargetScan , PITA, miRWalk and ensemble respectively")
```


```{r, echo=FALSE, results='asis'}

#scale all the scores to have range of 0-1
output_with_ensembl$targetscan$threshold <- (output_with_ensembl$targetscan$threshold - min(output_with_ensembl$targetscan$threshold))/(max(output_with_ensembl$targetscan$threshold) - min(output_with_ensembl$targetscan$threshold))
output_with_ensembl$mirwalk$threshold <- (output_with_ensembl$mirwalk$threshold - min(output_with_ensembl$mirwalk$threshold))/(max(output_with_ensembl$mirwalk$threshold) - min(output_with_ensembl$mirwalk$threshold))
output_with_ensembl$pita$threshold <- (output_with_ensembl$pita$threshold - min(output_with_ensembl$pita$threshold))/(max(output_with_ensembl$pita$threshold) - min(output_with_ensembl$pita$threshold))


plot(output_with_ensembl$targetscan$threshold, output_with_ensembl$targetscan$PPV, type = 'l',ylim = c(0,1), xlim = c(0,1), col = "green", xlab = "thresholds", ylab = "precision")
lines(output_with_ensembl$pita$threshold, output_with_ensembl$pita$PPV, type = 'l', col = "red")
lines(output_with_ensembl$mirwalk$threshold, output_with_ensembl$mirwalk$PPV, type = 'l', col = "pink")
lines(output_with_ensembl$ensembl$threshold, output_with_ensembl$ensembl$PPV, type = 'l', col = "black")


plot(output_with_ensembl$targetscan$threshold, output_with_ensembl$targetscan$SENS, type = 'l',ylim = c(0,1), xlim = c(0,1), col = "green", xlab = "thresholds", ylab = "recall")
lines(output_with_ensembl$pita$threshold, output_with_ensembl$pita$SENS, type = 'l', col = "red")
lines(output_with_ensembl$mirwalk$threshold, output_with_ensembl$mirwalk$SENS, type = 'l', col = "pink")
lines(output_with_ensembl$ensembl$threshold, output_with_ensembl$ensembl$SENS, type = 'l', col = "black")
```


